== <s>V2.19</s> ==
<s>* Fix major optimizer bugs, so it works like V2.13.3 again [https://github.com/cc65/cc65/issues/781 #781]</s>

== V3 Floating point support ==

Summary of the discussion in 2004 (without IEEE 754-2008 knowledge of course):

* An agreed floating point number format
* 6502 conversion routines from int <-> float and back
* 6502 routines to support + - * / < > <= >= == != operators
* changes of the compiler, assembler and linker
* 6502 ASCII <-> FP conversion functions (e.g. for scanf/printf)
* A 6502 math library (pow(), exp(), sin(), cos(), ... the works)


=== 32 vs. 48 bit ===

{|
! 32 bit !! 48 bit
|-
|
* "Standard" (whatever that's worth).
* Needs slightly less memory and is faster.
* Compiler can use native FP routines. But: Limits number of host platforms.
* Doesn't meet ISO C requirements.
* Less precision.
* Binary format is given and we have to live with that.
* Is suboptimal wrt. exponent processing (8 bit covered in 2 bytes).
|
* Needs slightly more memory and is slower.
* Compiler needs FP library. But: will work on all host platforms.
* Will meet the ISO C requirements.
* Better precision.
* Binary format can be optimized for 6502.
* Could be made optimal wrt. exponent processing.
* Implementation needs more code, so programs have a larger memory footprint.
|}


=== Conclusion ===

* support the ISO C standard: IEEE 32 bit format

The C standard allows setting errno, raising an exception, or just ignoring the condition for most operations. The standard does not require NaNs and infinite values, so it may be an option not to implement them, because this removes all corresponding checks in the math functions resulting in smaller code size. The TMS320 DSP has this behaviour and it's quite convenient.

[http://web.archive.org/web/20180419150129/http://grouper.ieee.org/groups/754/ IEEE 754-2008] (archived)

[http://www.jhauser.us/arithmetic/ IEEE 754 test suite]

[http://codebase64.org/doku.php?id=base:floating_point_routines_for_the_6502 Steve Wozniak's implementation]

[https://github.com/mrdudz/cc65-floatlib cc65-floatlib] is "a naive approach for using kernal floating point numbers on C64, while using IEEE float values at application level"

== V4 24 bit support ==
* Native 65816 code generation
* Full 6280 address space

== MEGA65 ==
# DMA memory copies/fills
# Hardware 32x32 fixed point multiplier
# Hardware 32/32 = 32.32 fixed point divider
# Fast CPU mode
# 4510 stack-relative opcodes
# 32-bit compound instructions
# Access to memory >64KB without bank switching etc.

first add assembler support:
* add support for new opcodes to the assembler (this seems to exist)
* provide linker configs for your target (missing)
then add support to the library:

* use extra capabilites of the hardware (new opcodes) in the runtime functions
* port the rest of the library (conio, drivers etc)
now add support to the simulator, so compiler changes can be tested in the regression tests

* update the cpu emulator
* add tests for this
last not least add support to the compiler:

* update the codegenerator
* improve the optimizer
* add a lot of regression tests to make sure you dont break something
