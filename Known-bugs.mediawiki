== Wrong implicit conversion of integers ==

While the standard says that an unsigned char should be promoted to int if an int can represent all values of an unsigned char, and similar for promotion from unsigned to long, cc65 promotes unsigned types to unsigned types of the larger range. That is, unsigned char is promoted to unsigned, and unsigned to unsigned long.

This can be easily tested. The following code should promote the operands to integer and produce signed results; but, if you look at the generated assembly, it uses the runtime routines for unsigneds, which generate unsigned results:

<pre>
int main(void)
{
    unsigned char c = 2;
    unsigned u = 2;
    int a = -2;
    long l = -2;

    /* Generated code should use tosmulax but uses tosumulax */
    int r = c * a;
    /* Generated code should use tosmuleax but uses tosumuleax */
    long lr = u * l;

    return 0;
}
</pre>

While, in the examples above, that has no ill effects, and is therefore only visible by looking at the generated code, there are other places where the compiler gets tests wrong, or produces invalid calculation results. For example:

<pre>
long n = -95;
unsigned int d = 3;
int r = n/d; // produces 21813 instead of 31
</pre>

A workaround is to manually force usage of the correct type:

<pre>
int r = n / (long) d;
</pre>

The disadvantage being that one must really understand the nature of the bug to apply the proper casts.

A fix is possible with not too much effort (needs rewrite of two functions in the compiler), but introduces two other problems:

* The fixed code has a higher chance to trigger an error in the optimizer which causes invalid code transformations. This optimizer problem does actually exist without the fix, but chances for triggering it are rather low.

* Fixing the conversions will have a negative impact on code quality. The reason is the integer promotions: The C standard says that operands to most binary operators must be converted to int. If that conversion is done to signed instead of unsigned, most operations on char will actually operate on signed ints. And on 6502 machines, code for a signed operation is usually larger and slower than the same code for an unsigned operation.

So, if you have plans to solve the issue, be at least prepared to have a thorough look at the generated code.

== Inconsistent result on divide with a negative numerator and a constant or variable denominator ==

When dividing a negative integer numerator by a constant number, or by a variable containing that same number, the compiler generates different results.

This sample code illustrates, and will erroneously print "Not Equal":
<pre>
#include <stdio.h>
void main(void)
{
	int a = -1, b = 8;
	if ((a/8) == (a/b))
		printf("Equal\n");
	else
		printf("Not Equal\n");
}
</pre>

Looking at the generated code, it's easy to see where the error lies.  The compiler substituted a shift operation for the divide-by-a-constant.  The shift operation doesn't yield the same answer as the divide if the numerator is negative.<br />For the case above, <tt>-1 >> 3 = -1</tt> and <tt>-1 / 8 = 0</tt>.
<pre>
;
; if ((a/8) == (a/b))
;
	ldy     #$03
	jsr     ldaxysp
	jsr     asrax3		; use >> 3 to divide by 8
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     tosdivax	; use divide code to divide by 8
</pre>

The optimizer switched to using <code>asrax3</code> for the constant division; and, used <code>tosdivax</code> for the division by the variable, resulting in <code>-1/8</code> not giving a consistent result, depending on whether the <tt>8</tt> is used as a literal or in a variable.

== equality comparison is evaluated wrong in some cases ==

Here is an example that demonstrates the behaviour:

<pre>
    #include <stdio.h>
    #include <stdint.h>

    int main ( void)
    {
      uint8_t  joy_state = 0x7e;
      printf("bad: %u\n", 0 == (joy_state & 1) );
      printf("good: %u\n", (joy_state & 1) == 0 );

      return 0;
    }
</pre>

This results in:

<pre>
bad: 0
good: 1
</pre>

The bug occurs when the optimizer tries to squeeze a 16-bit comparison into an 8-bit comparison.  It squeezes correctly from the pattern made by "(joy_state & 1) == 0"; but, squeezes incorrectly from the pattern made by "0 == (joy_state & 1)".

see http://www.cc65.org/mailarchive/2014-10/11680.html
